<!DOCTYPE html>
<html lang="ja">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
<meta http-equiv="Content-Type" content="text/htm;charset=UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>鱧ディレクター</title>
<link rel="apple-touch-icon" href="./harmony.png" />
<link rel="icon" type="image/png" href="./harmony.png">
<link rel="icon" type="image/svg+xml" sizes="any" href="./harmony.svg" />
<body>
<style>
body {
    font-family: "HG明朝E", serif;
    margin: 0;
    background-color: #BED9C2; <!--淡緑-->
}
h1 {
    position: relative;
    background: linear-gradient(to bottom, turquoise 0%, black 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    -webkit-box-reflect: below -18px linear-gradient(to bottom,rgba(0,0,0,0),rgba(0,0,0,0) 10%,rgba(0, 0, 0, 0.6));
    margin: 4px;
    margin-bottom: 1em;
    font-size: 1.7em;
}
/*table {
    border-collapse: collapse;
    border-spacing: 10px 5px;
    box-sizing: content-box;
}*/
table, td {
    border-collapse: collapse;
}
td:first-child{
    text-align: right;
}
td input:first-child, td label {
    margin-left: 10px;
}
td.range-td {
    text-align: right;
    display: block;
}
.piano {
    position: relative;
    height: 160px;
    margin: 0px;
}
.white-keys {
    position: absolute;
    left: 0px;
    display: flex;
}
.white-keys .keyboards {
    box-sizing: border-box;
    width: 44px;
    height: 150px;
    border: solid 1px black;
    background-color: white;
    border-bottom: solid 4px #eee;
}
.black-keys {
    display: flex;
    position:absolute;
    top: 0px;
    left: 30px;
}
.black-keys .keyboards {
    box-sizing: border-box;
    width: 30px;
    height: 70px;
    border: solid 1px black;
    margin-right:  14px;
    background-color: black;
    border-bottom: solid 4px #333;
}
.keyboards {
    border-radius: 0 0 3px 3px;
    box-shadow: 1px 2px 5px rgba(0,0,0,0.6);
}
.key-space {
    visibility: hidden;
    z-index: -9999;
}
.keyboard-press {
    background-color: #ccc !important;
    border-bottom: solid 1px black !important;
    box-shadow: 1px 1px 4px rgba(0,0,0,0.4) inset;
}
label {
    position: relative;
    display: inline-block;
    box-sizing: border-box;
}
input[type="checkbox"] {
    display: none;
}
.switch-label {
    position: relative;
    padding: 5px 5px 5px 45px;
    transition: .2s;
    border-radius: 8px;
    border: 1px solid #dfd;
    display: inline-block;
    line-height: 1;
}
input[type="checkbox"]:checked + .switch-label {
    background: turquoise;
    color: black;
    border: 1px solid turquoise;
    text-shadow: 1px 1px 2px white;
}
input[type="checkbox"]:checked + .switch-label:before {
    border: 1px solid turquoise;
}
input[type="checkbox"]:checked + .switch-label:after {
    left: 26px;
    background: turquoise;
}
.switch-label:before {
    content: "";
    display: block;
    left: 9px;
    width: 30px;
    height: 15px;
    border-radius: 15px;
    border: 1px solid #aaa;
    background: white;
    position: absolute;
}
.switch-label:after {
    content: "";
    display: block;
    position: absolute;
    top: 7px;
    left: 11px;
    width: 13px;
    height: 13px;
    background: #aaa;
    border-radius: 50%;
    transition: .2s;
    display: block;
}
input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background-color: turquoise;
    box-shadow: 1px 1px 4px #dfd;
    height: 2px;
    width: 70%;
    border-radius: 6px;
    display: inline-block;
}
input[type="range"]:focus,input[type="range"]:active {
    outline: none;
}
input[type="range"]:-webkit-slider-thumb,input[type="range"]:-moz-range-thumb {
    -webkit-appearance: none;
    appearance: none;
    cursor: pointer;
    position: relative;
    width: 20px;
    height: 20px;
    display: block;
    border: 2px solid #dfd;
    background-color: white;
    border-radius: 50%;
    -webkit-border-radius: 50%;
}
.wrapSelect {
    overflow: hidden;
    width: 40%;
    text-align: center;
}
.wrapSelect select {
    width: 90%;
    padding: 0.1em 15px 0.1em 0.2em;
    text-overflow: ellipsis;
    border: none;
    outline: none;
    background: transparent;
    background-image: none;
    box-shadow: none;
    -webkit-appearance: none;
    appearance: none;
}
.wrapSelect {
    position: relative;
    height: 1.4em;
    border: 2px solid turquoise;
    border-radius: 50px;
    background: #dfd;
    display: inline-table;
    border-collapse: separate;
}
.wrapSelect:before {
    position: absolute;
    top: 0.8em;
    right: 0.8em;
    width: 0;
    height: 0;
    padding: 0;
    content: '';
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 6px solid turquoise;
}
.plus-button, .minus-button {
    padding: 0 2px;
    display: inline-block;
    font-weight: bold;
    border: 1px solid #dfd;
    border-radius: 4px;
    color: white;
    background-image: linear-gradient(darkturquoise 0%, turquoise 100%);
    width: 10%;
}
.minus-button {
    margin-left: 0;
}
.plus-button:active, .minus-button:active {
    -webkit-transform: translateY(2px);
    transform: translateY(2px);
    border-bottom: none;
}
input[type="radio"] {
    opacity: 0;
    position: absolute;
}
.radio-label {
    display: inline-block;
    margin: auto;
    padding: 2px .4em;
    border: 1px solid #dfd;
    border-radius: .5em;
    border-collapse: collapse;
    transition: all .2s;
}
input[type="radio"]:checked + .radio-label {
    background: #dfd;
    background-image: linear-gradient(darkturquoise 0%, turquoise 100%);
    color: black;
    text-shadow: 1px 1px 2px white;
}

</style>
<h1>鱧ディレクター</h1>
<span id="chordView"></span>
<div id="piano-wrapper">
<div class="piano">
    <div class="white-keys">
        <div class="keyboards" name="C1"></div>
        <div class="keyboards" name="D1"></div>
        <div class="keyboards" name="E1"></div>
        <div class="keyboards" name="F1"></div>
        <div class="keyboards" name="G1"></div>
        <div class="keyboards" name="A1"></div>
        <div class="keyboards" name="H1"></div>
        <div class="keyboards" name="C2"></div>
        <div class="keyboards" name="D2"></div>
        <div class="keyboards" name="E2"></div>
        <div class="keyboards" name="F2"></div>
        <div class="keyboards" name="G2"></div>
        <div class="keyboards" name="A2"></div>
        <div class="keyboards" name="H2"></div>
        <div class="keyboards" name="C3"></div>
    </div>
    <div class="black-keys">
        <div class="keyboards" name="Cis1"></div>
        <div class="keyboards" name="Es1"></div>
        <div class="keyboards key-space"></div>
        <div class="keyboards" name="Fis1"></div>
        <div class="keyboards" name="As1"></div>
        <div class="keyboards" name="B1"></div>
        <div class="keyboards key-space"></div>
        <div class="keyboards" name="Cis2"></div>
        <div class="keyboards" name="Es2"></div>
        <div class="keyboards key-space"></div>
        <div class="keyboards" name="Fis2"></div>
        <div class="keyboards" name="As2"></div>
        <div class="keyboards" name="B2"></div>
    </div>
</div>
<div class="piano">
    <div class="white-keys">
        <div class="keyboards" name="C3"></div>
        <div class="keyboards" name="D3"></div>
        <div class="keyboards" name="E3"></div>
        <div class="keyboards" name="F3"></div>
        <div class="keyboards" name="G3"></div>
        <div class="keyboards" name="A3"></div>
        <div class="keyboards" name="H3"></div>
        <div class="keyboards" name="C4"></div>
        <div class="keyboards" name="D4"></div>
        <div class="keyboards" name="E4"></div>
        <div class="keyboards" name="F4"></div>
        <div class="keyboards" name="G4"></div>
        <div class="keyboards" name="A4"></div>
        <div class="keyboards" name="H4"></div>
        <div class="keyboards" name="C5"></div>
    </div>
    <div class="black-keys">
        <div class="keyboards" name="Cis3"></div>
        <div class="keyboards" name="Es3"></div>
        <div class="keyboards key-space"></div>
        <div class="keyboards" name="Fis3"></div>
        <div class="keyboards" name="As3"></div>
        <div class="keyboards" name="B3"></div>
        <div class="keyboards key-space"></div>
        <div class="keyboards" name="Cis4"></div>
        <div class="keyboards" name="Es4"></div>
        <div class="keyboards key-space"></div>
        <div class="keyboards" name="Fis4"></div>
        <div class="keyboards" name="As4"></div>
        <div class="keyboards" name="B4"></div>
    </div>
</div></div>
<table>
<tr><th>持続</th>
    <td><label for="sustein"><input type="checkbox" id="sustein" name ="sustein"/><span class="switch-label">持続する</span></label></td>
</tr>
<tr><th>基準周波数</th>
    <td><input type="range" id="stdFreq" min="435" max="445" value="442"/></td>
    <td id="stdFreqVal"></td>
</tr>
<tr><th>調</th>
    <td><div><div class="wrapSelect"><select id="scale">
        <option value="ave" selected="">平均律</option>
        <option value="C">C</option>
        <option value="Cis">C♯</option>
        <option value="D">D</option>
        <option value="Es">E♭</option>
        <option value="E">E</option>
        <option value="F">F</option>
        <option value="Fis">F♯</option>
        <option value="G">G</option>
        <option value="As">A♭</option>
        <option value="A">A</option>
        <option value="B">B♭</option>
        <option value="H">B</option>
    </select></div>
    <label for="major"><input type="radio" name="key" id="major" value="major" checked="" /><span class="radio-label">長調</span></label>
    <label for="minor"><input type="radio" name="key" id="minor" value="minor" /><span class="radio-label">短調</span></label></div>
    <label for="keyAuto"><input type="checkbox" id="keyAuto" name ="keyAuto"/><span class="switch-label">自動</span></label>
</td></tr>
<tr><th>音色</th>
<td><div class="wrapSelect"><select id="toneColor">
    <option value="sine" selected="">正弦波</option>
    <option value="square">矩形波</option>
    <option value="sawtooth">鋸波</option>
    <option value="triangle">三角波</option>
    <!--option value="custom" disabled="">その他(未実装)</option-->
</select></div></td></tr>
<tr>
    <th>アタック</th>
    <td><input type="range" id="attack" min="0" max="100" value="80"/></td>
    <td id="attackVal"></td>
</tr>
<tr>
    <th>リリース</th>
    <td><input type="range" id="release" min="0" max="100" value="50"/></td>
    <td id="releaseVal"></td>
</tr>
<tr><th>音域</th>
    <td><div id="range-of-octave">
    <label for="low"><input type="radio" name="range-of-octave" id="low" value="2" /><span class="radio-label">低音</span></label>
    <label for="midium"><input type="radio" name="range-of-octave" id="midium" value="1" checked="" /><span class="radio-label">中音</span></label>
    <label for="high"><input type="radio" name="range-of-octave" id="high" value="0" /><span class="radio-label">高音</span></label>
    </div>
</td></tr>
<tr><th>メトロノーム</th>
    <td><div class="switch">
        <label for="metro"><input type="checkbox" id="metro" name="metro"/><span class="switch-label">再生する</span></label>
    </div></td>
</tr>
<tr>
    <td>テンポ</td>
    <td><input type="range" id="tempo" min="40" max="300" value="100"/></td>
    <td id="tempoVal"></td>
</tr>
<tr><td>強拍</td>
    <td><input type="range" id="stressVol" min="0" max="100" value="100"/></td>
    <td id="stressVal"></td>
</tr>
<tr><td>4分音符</td>
    <td><input type="range" id="fourVol" min="0" max="100" value="80"/></td>
    <td id="fourVal"></td>
</tr>
<tr><td>8分音符</td>
    <td><input type="range" id="eightVol" min="0" max="100" value="20"/></td>
    <td id="eightVal"></td>
</tr>
<tr><td>3連符</td>
    <td><input type="range" id="tripletVol" min="0" max="100" value="0"/></td>
    <td id="tripletVal"></td>
</tr>
<tr><td>16分音符</td>
    <td><input type="range" id="sixteenVol" min="0" max="100" value="0"/></td>
    <td id="sixteenVal"></td>
</tr>
<tr><td>拍子</td>
<td><div class="signature" id="signature">
    <div>
    <label for="sign1"><input type="radio" name="signature-numerator" id="sign1" value="1" /><span class="radio-label">1</span></label>
    <label for="sign2"><input type="radio" name="signature-numerator" id="sign2" value="2" /><span class="radio-label">2</span></label>
    <label for="sign3"><input type="radio" name="signature-numerator" id="sign3" value="3" /><span class="radio-label">3</span></label>
    <label for="sign4"><input type="radio" name="signature-numerator" id="sign4" value="4" checked="" /><span class="radio-label">4</span></label>
    </div>
    <label for="sign0"><input type="radio" name="signature-numerator" id="sign0" value="other" /><span class="radio-label">複合拍子</span></label>
    <input type="text" id="compound-signature" placeholder="ex. 2+3, 4+2 etc..."></div>
</div></td>
</tr>
</table>
<br />
<!--
<p>自動再生</p>
<label for="auto-player"><input type="checkbox" id="auto-player" /><span class="switch-label">再生／停止</span></label>
<textarea id="auto-play-text" placeholder="c,c,e,g|ceg|c"></textarea>
-->
<br />
<script>
window.AudioContext = window.AudioContext || window.webkitAudioContext;
const audioctx = new AudioContext();
const ana = audioctx.createAnalyser();
const pianoElm = document.getElementById("piano-wrapper");
const keyboards = document.getElementsByClassName("keyboards");
const stdFreqElm = document.getElementById("stdFreq");
const colorElm = document.getElementById("toneColor");
const scale = document.getElementById("scale");
const chordElm = document.getElementById("chordView");
const attackElm = document.getElementById("attack");
const releaseElm = document.getElementById("release");
const keyElm = document.querySelectorAll("input[name='key']");
const rangeElm = document.getElementById("range-of-octave").querySelectorAll("input");
const autoElm = document.getElementById("keyAuto");
let majorOrMinor;
let currentOctave;
const freqRatio = {};
freqRatio.major = [1, 25/24, 9/8, 6/5, 5/4, 4/3, 25/18, 3/2, 25/16, 5/3, 9/5, 15/8, 2];
freqRatio.minor = [1, 27/25, 9/8, 6/5, 5/4, 4/3, 36/25, 3/2, 8/5, 5/3, 9/5, 15/8, 2];
const toneNames = [
    "A0", "B0", "H0",
    "C1","Cis1", "D1", "Es1", "E1", "F1", "Fis1", "G1", "As1", "A1", "B1", "H1",
    "C2","Cis2", "D2", "Es2", "E2", "F2", "Fis2", "G2", "As2", "A2", "B2", "H2",
    "C3","Cis3", "D3", "Es3", "E3", "F3", "Fis3", "G3", "As3", "A3", "B3", "H3",
    "C4","Cis4", "D4", "Es4", "E4", "F4", "Fis4", "G4", "As4", "A4", "B4", "H4",
    "C5"
];
const scales = ["A", "B", "H", "C","Cis", "D", "Es", "E", "F", "Fis", "G", "As"];
const tone = {};
const playing = {};
let isLongtone = false;


setMajorOrMinor();
setRangeOctave();
pianoElm.ontouchstart = (e) => {
    const toneName = e.target.getAttribute("name");
    if (toneNames.includes(toneName)) {
        e.preventDefault();
        playTone(toneName, e.target);
        e.target.classList.add("keyboard-press");
    }
}
showParam(attackElm, "attackVal");
let attackTimeConst = (100 - attackElm.value) * 1e-3;
attackElm.oninput = () => {
    showParam(attackElm, "attackVal");
    attackTimeConst = (100 - attackElm.value) * 1e-3;
}
showParam(releaseElm, "releaseVal");
let releaseTimeConst = releaseElm.value * 1e-3;
releaseElm.oninput = () => {
    showParam(releaseElm, "releaseVal");
    releaseTimeConst = releaseElm.value * 1e-3;
}
function playTone(toneName, e) {
    if (isLongtone) {
        stopPlay();
    }
    if (!playing[toneName]) {
        const osc = audioctx.createOscillator();
        const gain = audioctx.createGain();
        const ana = audioctx.createAnalyser();
        const i = toneNames.indexOf(toneName);
        playing[toneName] = {osc, gain, ana, elm: e, i};
        let keyScale = scale.value;
        if (autoElm.checked) {
            let playingTones = Object.keys(playing).filter(key => playing[key]);
            playingTones = playingTones.map(str => str.slice(0, -1));
            playingTones = [...new Set(playingTones)];
            if (playingTones.length >= 3) {
                let lowest = 88;
                for (let j = 0; j < Object.keys(playing).length; j++) {
                    if (playing[Object.keys(playing)[j]].i < lowest) {
                        lowest = playing[Object.keys(playing)[j]].i;
                    }
                }
                const chord = chordCheck(playingTones, toneNames[lowest].slice(0, -1));
                if (chord) {
                    keyScale = chord.key;
                    chordElm.textContent = keyScale + " " + chord.chordStr;
                    changeToneFreq(keyScale);
                    scale.value = keyScale;
                }
            }
        }

        const freq = getFreqByScaleInterval(keyScale, i);
        osc.frequency.value = freq;
        osc.type = colorElm.value;
        gain.gain.value = 0;
        osc.connect(gain);
        gain.connect(ana);
        ana.connect(audioctx.destination);
        osc.start();
        gain.gain.setTargetAtTime(1, audioctx.currentTime, attackTimeConst);
    }
}
colorElm.onchange = () => {
    changeToneType(colorElm.value);
}
scale.onchange = () => changeToneFreq();

function changeToneType(type) {
    for (let osc of Object.keys(playing)) {
        playing[osc].osc.type = type;
    }
}
function changeToneFreq(key = scale.value) {
    for (let osc of Object.keys(playing)) {
        const freq = getFreqByScaleInterval(key, toneNames.indexOf(osc));
        playing[osc].osc.frequency.value = freq;
    }
}
function chordCheck(tones, lowest) {
    if (tones.length > 4) {
        return false;
    }
    console.log(lowest)
    let notes = [];
    const n = tones.length;
    tones.forEach(note => {
        notes.push(scales.indexOf(note));
    });
    notes.sort((a, b) => {
        return (a > b) ? 1 : -1;
    });

    const lowestNum = scales.indexOf(lowest);
    let splitIndex = 0;
    while (notes[splitIndex++] < lowestNum) continue;
    splitIndex--;
    notes = [...notes.slice(splitIndex, n), ...notes.slice(0, splitIndex)];
    console.log(notes)
    const toneDistance = (base, higher) => {
        return (higher > base) ? higher - base : (12 + higher - base) % 12;
    }

    for (let i = 0; i < n; i++) {
        const distances = [];
        for (let j = 0; j < n; j++) {
            distances.push(toneDistance(notes[0], notes[j]));
        }
        const baseToneName = scales[notes[0]];
        const chordList = {
            "0,4,7": "major",
            "0,3,7": "minor",
            "0,5,7": "sus4",
            "0,2,7": "sus2",
            "0,4,7,10": "7",
            "0,3,7,10": "m7",
            "0,4,7,11": "M7",
            "0,3,6,10": "m7-5",
            "0,5,7,10": "7sus4",
            "0,4,8": "aug",
            "0,3,6": "diminish",
            "0,3,7,11": "mM7",
            "0,4,7,9": "6",
            "0,3,7,9": "m6",
            "0,4,6,10": "7-5",

            // "0,2,4,7": "I on II"
        }
        const prop = distances.join();
        if (prop in chordList) {
            return {
                key: baseToneName,
                chordStr: chordList[prop]
            }
        } else {
            notes.push(notes[0]);
            notes.shift();
        }
    }
    return "";
}

function getFreqByScaleInterval(scale, interval) {
    let stdInterval = scales.indexOf(scale);
    const stdFreq = stdFreqElm.value / (2 ** currentOctave);
    const currentFreq = freqRatio[majorOrMinor];
    if (~stdInterval) {
        const referFreq = stdFreq / 2 * 2 ** (stdInterval / 12);
        const degree = (12 + interval - stdInterval) % 12;
        const octave = ~~((12 + interval - stdInterval) / 12);
        return (referFreq * currentFreq[degree]) * 2 ** octave;
    } else {
        return stdFreq * (2 ** (interval / 12));
    }
}

function setMajorOrMinor() {
    for (let elm of keyElm) {
        if (elm.checked) {
            majorOrMinor = elm.value;
        }
    }
}
function setRangeOctave() {
    for (let elm of rangeElm) {
        if (elm.checked) {
            currentOctave = elm.value - 0;
        }
    }
}
for (let elm of keyElm) {
    elm.onchange = () => {
        setMajorOrMinor();
        changeToneFreq();
    }
}
for (let elm of rangeElm) {
    elm.onchange = () => {
        setRangeOctave();
        changeToneFreq();
    }
}
pianoElm.ontouchend = (e) => {
    const toneName = e.target.getAttribute("name");
    if (toneName) {
        e.preventDefault();
        stopPlay(toneName, e);
    }   
}
const susteinElm = document.getElementById("sustein");
susteinElm.onchange = () => {
    if (!susteinElm.checked) {
        stopPlay();
    }
}
function stopPlay(toneName, event){
    if(!toneName) {
        for (let osc of Object.keys(playing)) {
            playing[osc].gain.gain.setTargetAtTime(0, audioctx.currentTime, releaseTimeConst);
            playing[osc].osc.stop(audioctx.currentTime + 0.05);
            playing[osc].elm.classList.remove("keyboard-press");
            delete playing[osc];
        }
        isLongtone = false;
    }
    if (susteinElm.checked) {
        if(event) {
            isLongtone = !event.touches[0];
        }
    } else if(playing[toneName]) {
        playing[toneName].gain.gain.setTargetAtTime(0, audioctx.currentTime, releaseTimeConst);
        playing[toneName].osc.stop(audioctx.currentTime + 5);
        playing[toneName].elm. classList.remove("keyboard-press");
        delete playing[toneName];
    }
}
stdFreqElm.addEventListener("input", showFreq);
showFreq();
function showFreq() {
    showParam(stdFreqElm, "stdFreqVal");
    if (Object.keys(playing).length) {
        changeToneFreq();
    }
}
class MetronomeNote {
    constructor(beatInt, name, elmId, pElmId, freq) {
        this.beatInterval = beatInt;
        this.noteName = name;
        this.element = document.getElementById(elmId);
        this.paramElement = document.getElementById(pElmId);
        this.frequency = freq;
        this.level = this.element.value;

        this.element.oninput = this.showParam.bind(this);
    }
    init() {
        this.osc = this.ctx.createOscillator();
        this.gain = this.ctx.createGain();

        this.osc.frequency.value = this.frequency;
        this.gain.gain.value = 0;
        this.osc.connect(this.gain);
        this.gain.connect(this.ctx.destination);
        /*
            if (this.buffer) {
                this.source = this.ctx.createBufferSource();
                this.source.buffer = AudioBuffer;
                this.source.connect(this.gain);  
                this.gain.connect(this.ctx.destination);  
                this.source.start();
                console.log(this.source)
            }
            */
        this.osc.start();
    }
    showParam() {
        this.paramElement.textContent = this.element.value;
        this.level = this.element.value;
    }
    reserveBeat(current48Beat, nextBeatTime, currentTimeSignature) {
        if (this.beatInterval) {
            if (current48Beat % this.beatInterval === 0) {
                this.gain.gain.setValueAtTime(this.level / 50, nextBeatTime);
                this.gain.gain.linearRampToValueAtTime(0, nextBeatTime + 0.05);
            }
        } else if (!currentTimeSignature && !current48Beat) {
            this.gain.gain.setValueAtTime(this.level / 50, nextBeatTime);
            this.gain.gain.linearRampToValueAtTime(0, nextBeatTime + 0.05);   
        }
    }
    set audioContext(ctx) {
        this.ctx = ctx;
        this.init();
    }
    set arrayBuffer(buffer) {
        this.buffer = buffer;
        this.init();
    }
}
/*
const stressBase64Data = "data:audio/wav;base64,UklGRuAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YbwAAAAnAEn8rfeB8tTs1ObX4Ejb6tWw0IfLQMaZwGq68rMWrd2laJ6Al/GR640EjpiTIJzep8q2aceN2ADpaPjHAloGYAcQBhkDRgDj/sX/MgKRCJUT/SAfMPk/s05tWLhbD1zMVrVKgzphJVgN8veC7uTy+/rxAOsBIwA0/ab6AvnU93r2xPTy8mjxKPB671vve+8a8Crxd/Le82n14fYg+Av53vly+uL6N/t++7D75/s8/Lr8U/0m/jX/bwD3AQ==";
let AudioBuffer;
function base64dataToArrayBuffer(data) {  
    /*
  var byteString = atob(data.split(',')[1])
  var len = byteString.length;
  var buffer = new Uint8Array(len);
  for (var i=0; i<len; ++i) {
    buffer[i] = byteString.charCodeAt(i);
  }
  return Uint8Array.from(atob(data.split(",")[1]), data => data.charCodeAt(0)).buffer
  //return buffer.buffer;
};
*/
const stress = new MetronomeNote(0, "stress", "stressVol", "stressVal", 2400);
const four = new MetronomeNote(12, "four", "fourVol", "fourVal", 1200);
const eight = new MetronomeNote(6, "eight", "eightVol", "eightVal", 1200);
const triplet = new MetronomeNote(4, "triplet", "tripletVol", "tripletVal", 1200);
const sixteen = new MetronomeNote(3, "sixteen", "sixteenVol", "sixteenVal", 1200);

const metronomeNotes = {
    stress, four, eight, triplet, sixteen
};
for (let note of Object.values(metronomeNotes)) {
    note.showParam();
}
function showParam(elm, name) {
    document.getElementById(name).textContent = elm.value;
}
const timeSignatureElm = document.getElementById("signature");
class MetronomeBeater {
    constructor() {   
    }
    start () {
        this.ctx = new AudioContext();
        this.currentTimeSignature = 0;
        this.current48Beat = 0;
        this.currentSignatureIndex = 0;
        this.isChangedSignature = false;
        const nowTimeStamp = performance.now();
        this.lastBeatTimeStamp = nowTimeStamp;
        this.nextBeatTimeStamp = nowTimeStamp;
        this.nextTimeSignature = this.nextNote.bind(this);
        this.baseTimeStamp = nowTimeStamp - this.ctx.currentTime * 1000;
        for (let note of Object.values(metronomeNotes)) {
            note.audioContext = this.ctx;
        }
        this.setTimeSignatureNumerator();
        (this.scheduler.bind(this))();
        this.intervalId = setInterval(this.scheduler.bind(this), 500);
        return {
            ctx: this.ctx,
            id: this.intervalId
        };
    }
    currentTimeStamp() {
        return this.baseTimeStamp + this.ctx.currentTime * 1000;
    }
    timeStampToAudioContextTime(timeStamp) {
        return (timeStamp - this.baseTimeStamp) / 1000;
    }
    nextNote() {
        const beatTick = 60 * 1000 / metroTempo;
        if (this.isChangedSignature) {
            this.currentSignatureIndex = 0;
            this.isChangedSignature = false;
        }
        this.nextBeatTimeStamp += beatTick / 12;
        this.current48Beat++;
        this.current48Beat %= 12;
        if (!this.current48Beat) {
            this.currentTimeSignature++;
            if (this.currentTimeSignature === this.signature[this.currentSignatureIndex]) {
                this.currentTimeSignature = 0;
                this.currentSignatureIndex++;
                this.currentSignatureIndex %= this.signature.length;
            }
        }
        return this;
    }
    setTimeSignatureNumerator() {
        (() => {
            let resultElm;
            for (let elm of timeSignatureElm.querySelectorAll("input")) {
                if (elm.checked) {
                    resultElm = elm;
                }
            }
            if (!(resultElm.value - 0)) {
                const compoundElm = document.getElementById("compound-signature");
                this.signature = compoundElm.value.split(/\+|,| /);
            }
            this.signature = [resultElm.value - 0];
        })()
    }
    scheduler() {
        const now = this.currentTimeStamp();
        while (this.nextBeatTimeStamp < now + 700) {
            let next48BeatTime = this.timeStampToAudioContextTime(this.nextBeatTimeStamp);
            for (let note of Object.values(metronomeNotes)) {
                note.reserveBeat(this.current48Beat, next48BeatTime, this.currentTimeSignature);
            }
            this.nextNote();
        }
    }
}

const beat = new MetronomeBeater();
const metroElm = document.getElementById("metro");
const tempoElm = document.getElementById("tempo");
let metroIntervalId, metroctx;
let metroTempo = tempoElm.value;
metroElm.onchange = metroHandler;
metroElm.checked = false;
function metroHandler() {
    if (metroElm.checked) {
        const obj = {id: metroIntervalId, ctx: metroctx} = beat.start();
    } else if (metroctx) {
        metroctx.close();
        clearInterval(metroIntervalId);
        metroIntervalId = null;
    }
}

showParam(tempoElm, "tempoVal");
tempoElm.oninput = () => {
    metroTempo = tempoElm.value;
    showParam(tempoElm, "tempoVal");
}

for (let elm of timeSignatureElm.querySelectorAll("input")) {
    elm.onchange = () => {
        beat.setTimeSignatureNumerator();
        beat.isChangedSignature = true;
    }
}

/**
* range関連
*/
for (let elm of document.querySelectorAll("input[type='range']")) {
    const beforeElm = document.createElement("input");
     with (beforeElm) {
        type = "button";
        classList.add("minus-button");
        value = "ー";
        onclick = prevent;
        ontouchstart = handler;
    }
    const afterElm = document.createElement("input");
    afterElm.type = "button";
    afterElm.classList.add("plus-button");
    afterElm.value = "＋";
    afterElm.onclick = prevent;
    afterElm.ontouchstart = handler;

    elm.insertAdjacentElement("beforebegin", beforeElm);
    elm.insertAdjacentElement("afterend", afterElm);
    function handler(e) {
        let elm;
        switch (e.target.value) {
            case "＋":
                elm = e.target.previousElementSibling;
                elm.value++;
                break;
            case "ー":
                elm = e.target.nextElementSibling;
                elm.value--;
                break;
        }
        elm.dispatchEvent(new Event("input"));
    }
    function prevent(e){
        e.preventDefault();
    }
}

/* 自動再生関連
const tonesArr = ["A", "B", "H", "C","Cis", "D", "Es", "E", "F", "Fis", "G", "As"];
const stdPitch = 442;
const tempo = 60;

const controler = document.getElementById("auto-player");
const textareaElm = document.getElementById("auto-play-text");
textareaElm.textContent = "c|cg|ceg,"
let obj;
let playDataByBar, playDataByNote, playDataByTone;
controler.onchange = () => {
    if (controler.checked) {
        // a|a,b,c|abc -> ["a","a,b,c","abc"]
        playDataByBar = textareaElm.textContent.split("|");
        // ->[["a"], ["a", "b", "c"], ["abc"]]
        playDataByNote = playDataByBar.map(notes => notes.split(","));
        // ->[[[a]], [[a],[b],[c]], [[a,b,c]]]
        playDataByTone = playDataByNote.map(note => note.map(tones => tones.split("")));

        obj = startAutoPlay();
    } else {
        obj.ctx.close();
        clearInterval(obj.id);
    }
}

function startAutoPlay() { 
    const ctx = new AudioContext(); 
    const baseTimeStamp = performance.now() - ctx.currentTime * 1000; 
    let currentBar = 0; 
    let currentIndex = 0; 
 
    const nowTime = performance.now(); 
    let lastNoteTimeStamp = nowTime; 
    let nextNoteTimeStamp = lastNoteTimeStamp;
    let nextNoteTime = timeStampToAudioContextTime(nextNoteTimeStamp);

 
    function scheduler() { 
        const now = currentTimeStamp(); 
        while (nextNoteTimeStamp < now + 800) { 
            for (let tone of playDataByTone) { 
                nextNoteTime = reserveNote(nextNoteTime); 
            } 
        } 
    } 
    scheduler(); 
    const intervalId = setInterval(scheduler, 500); 
    return { 
        ctx, 
        id: intervalId 
    };

    function reserveNote(nextNoteTime) {
        const tonesReserve = playDataByTone[currentBar][currentIndex]
        nextNote();
        const nextnextNoteTime = timeStampToAudioContextTime(nextNoteTimeStamp);
        for (const tone of tonesReserve) {
            const freq = stdPitch * (2 ** (tonesArr.indexOf(tone.toUpperCase()) / 12)); 
            const osc = ctx.createOscillator();
            const gain = ctx.createGain(); 
            osc.frequency.value = freq;
            gain.gain.value = 0;
            gain.gain.setValueAtTime(1, nextNoteTime);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(nextnextNoteTime);
        }
        return nextnextNoteTime;
    } 
    function nextNote() { 
        const beatTick = 60 * 1000 / tempo;
        const notesInBar = playDataByNote[currentBar].length; 
        nextNoteTimeStamp += beatTick / notesInBar; 
        currentIndex++; 
        if (currentIndex === notesInBar) { 
            currentIndex = 0; 
            currentBar++;
            if(currentBar === playDataByBar.length) {
                currentBar = 0;
            }
        } 
    } 
    function currentTimeStamp() { 
        return baseTimeStamp + ctx.currentTime * 1000; 
    } 
    function timeStampToAudioContextTime(timeStamp) { 
        return (timeStamp - baseTimeStamp) / 1000; 
    } 
}
*/
</script>
</body>
</html>
