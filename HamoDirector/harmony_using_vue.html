<!DOCTYPE html>
<html lang="ja">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
<meta http-equiv="Content-Type" content="text/htm;charset=UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>鱧ディレクター</title>
<link rel="apple-touch-icon" href="./harmony.png" />
<link rel="icon" type="image/png" href="./harmony.png">
<link rel="icon" type="image/svg+xml" sizes="any" href="./harmony.svg" />
<body>
<style>
:root {
    /* color set*/
    --active-cute: #ff82a9;
    --active-grad-cute: #ff72d0;
    --background-cute: #ffebe7;
    --border-cute: violet;
    --shadow-cute: hotpink;

    --active-cool: lightskyblue;
    --active-grad-cool: deepskyblue;
    --background-cool: paleturquoise;
    --border-cool: royalblue;
    --shadow-cool: aqua;

    --active-natural: limegreen;
    --active-grad-natural: mediumseagreen;
    --background-natural: #CFC;
    --border-natural: forestgreen;
    --shadow-natural: darkcyan;
}

body {
    font-family: "ヒラギノ丸ゴ ProN", "HG丸ｺﾞｼｯｸM-PRO", serif;
    text-shadow: 0.1em 0.2em 0.1em rgba(0, 0, 0, 0.2);
    margin: 0;

    background-color: var(--background);
}
#top-menu {
    position: relative;
    height: 2em;
}
h1 {
    position: relative;
    background: linear-gradient(to bottom, var(--active) 0%, var(--active-grad) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    -webkit-box-reflect: below -18px linear-gradient(to bottom,rgba(0,0,0,0),rgba(0,0,0,0) 10%,rgba(0, 0, 0, 0.6));
    margin: 4px;
    margin-bottom: 1em;
    font-size: 1.7em;
}
h2 {
    margin: 0;
    display: inline-block;
}
.td:first-child{
    text-align: right;
    padding-right: 5px;
}
.td.range-td {
    text-align: right;
    display: block;
}
#control-panel {
    display: table;
    border-spacing: 4px;
}
.block {
    display: table-row;
}
.th, .td {
    display: table-cell;
    height: 1.6em;
    text-shadow: 0.1em 0.2em 0.1em rgba(0, 0, 0, 0.2);
}
.th {
    text-align: center;
    vertical-align: middle;
    padding-right: 5px;
}
.piano {
    position: relative;
    height: 160px;
    margin: 0px;
}
.white-keys {
    position: absolute;
    left: 0px;
    display: flex;
}
.white-keys .keyboards {
    box-sizing: border-box;
    width: 44px;
    height: 150px;
    border: solid 1px black;
    background-color: white;
    border-bottom: solid 4px #eee;
}
.black-keys {
    display: flex;
    position:absolute;
    top: 0px;
    left: 30px;
}
.black-keys .keyboards {
    box-sizing: border-box;
    width: 30px;
    height: 70px;
    border: solid 1px black;
    margin-right:  14px;
    background-color: black;
    border-bottom: solid 4px #333;
}
.keyboards {
    border-radius: 0 0 3px 3px;
    box-shadow: 1px 2px 5px rgba(0,0,0,0.6);
}
.key-space {
    visibility: hidden;
}
.keyboard-press {
    background-color: #ccc !important;
    border-bottom: solid 1px black !important;
    box-shadow: 1px 1px 4px rgba(0,0,0,0.4) inset;
}
label {
    position: relative;
    display: inline-block;
    box-sizing: border-box;
}
input[type="checkbox"] {
    display: none;
}
.switch-label {
    position: relative;
    padding: 5px 5px 5px 45px;
    transition: .2s;
    border-radius: 8px;
    border: 1px solid var(--border);
    display: inline-block;
    line-height: 1em;
}
input[type="checkbox"]:checked + .switch-label {
    background: var(--active);
    color: black;
    border: 1px solid var(--active);
    text-shadow: 1px 1px 2px white;
}
input[type="checkbox"]:checked + .switch-label:before {
    border: 1px solid var(--active);
}
input[type="checkbox"]:checked + .switch-label:after {
    left: 26px;
    background: var(--active);
}
.switch-label:before {
    content: "";
    display: block;
    left: 9px;
    width: 30px;
    height: 15px;
    border-radius: 15px;
    border: 1px solid var(--border);
    background: white;
    position: absolute;
}
.switch-label:after {
    content: "";
    display: block;
    position: absolute;
    top: 7px;
    left: 11px;
    width: 13px;
    height: 13px;
    background: #aaa;
    border-radius: 50%;
    transition: .2s;
    display: block;
}
input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background-color: var(--active);
    box-shadow: 1px 1px 4px var(--shadow);
    height: 2px;
    width: calc(100% - (1em + 8px) * 2);
    border-radius: 6px;
    display: inline-block;
}
.wrapSelect {
    overflow: hidden;
    width: 6em;
    text-align: center;
    margin-left: 0.4em;
}
.wrapSelect select {
    width: 90%;
    padding: 0.1em 15px 0.1em 0.2em;
    text-overflow: ellipsis;
    border: none;
    outline: none;
    background: transparent;
    background-image: none;
    box-shadow: none;
    -webkit-appearance: none;
    appearance: none;
}
.wrapSelect {
    position: relative;
    height: calc(1em + 8px);
    border: 1.5px solid var(--active-grad);
    margin: 1px;
    border-radius: 50px;
    background: var(--background);
    display: inline-block;
    vertical-align: bottom;
    border-collapse: separate;
}
.wrapSelect:before {
    position: absolute;
    top: calc(0.5em + 2px);
    right: 0.5em;
    width: 0;
    height: 0;
    padding: 0;
    content: '';
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 6px solid var(--active-grad);
}
.plus-button, .minus-button {
    display: inline-block;
    font-weight: bold;
    border: 1px solid var(--border);
    border-radius: 4px;
    color: white;
    background-image: linear-gradient(var(--active-grad) 0%, var(--active) 100%);
    width: calc(1em + 6px);
    padding: 0 2px;
}
.minus-button {
    margin-left: 0;
}
.plus-button:active, .minus-button:active {
    -webkit-transform: translateY(2px);
    transform: translateY(2px);
    border-bottom: none;
}
input[type="radio"] {
    opacity: 0;
    position: absolute;
}
.radio-label {
    display: inline-block;
    margin: auto;
    padding: 2px .4em;
    border: 1px solid var(--border);
    border-radius: .5em;
    border-collapse: collapse;
    transition: all .2s;
}
input[type="radio"]:checked + .radio-label {
    background: var(--shadow);
    background-image: linear-gradient(var(--active) 0%, var(--active) 100%);
    color: black;
    text-shadow: 1px 1px 2px white;
}
button {
    color: black;
    padding: 0.1em 0.5em;
    background: transparent;
    border-radius: 30px;
    border: 2px solid var(--active);
    box-shadow: 1px 1px 1px rgba(0,0,0,0.4);
}
.drawer {
    width: 21em;
    position: absolute;
    padding: 1em 1em;
    border: solid 2px var(--active-grad);
    border-radius: 10px;
    background-color: var(--background);
    right: 100%;
    top: 2em;
    transition: .3s;
    visibility: hidden;
    opacity: 0;
}
.drawer.show {
    visibility: visible;
    opacity: 1;
    transform: translateX(100%);
}
.drawer > div {
    margin-left: auto;
    margin-right: auto;
}
.dragging {
    transition: 0s;
}
#metronome input[type="range"] {
    width: calc(100% - (1em + 8px) * 2);
}
#metronome input[type="text"] {
    width: 5em;
    padding: 2px;
    border: none;
    border-radius: 0.5em;
    box-shadow: 0 0 0.2em var(--border);
    transition: .3s;
}
#metronome input[type="text"]:focus {
    box-shadow: 0 0 1px 1px var(--active);
    outline: 0;
}
#metronome .th {
    min-width: 4em;
}
#metronome .td:nth-child(2) {
    width: calc(100% - 7em);
}
#control-button {
    position: absolute;
    top: 0;
    right: 1em;
}
.close-window {
    position: relative;
    display: block;
    margin-left: auto;
    margin-right: 1em;
}
#tuner {
    width: 60vw;
    height: auto;
}
.canvas-container {
    height: 0;
    padding-top: 56.25%;
    position: relative;
}
canvas {
    position: absolute;
    top: 0;
    display: block;
    width: 100%;
    height: 100%;
}
</style>
<script src="https://jp.vuejs.org/js/vue.min.js"></script>
<h1>鱧ディレクター</h1>
<div id="top-menu">
    <span id="chordView">&nbsp;</span>
    <div id="control-button">
        <button onclick="showFromLeft('metronome')">メトロノーム</button>
        <button onclick="showFromLeft('tone-color')">音色</button>
        <button onclick="showFromLeft('tuner')">チューナー</button>
        <button onclick="showFromLeft('settings')">設定</button>
    </div>
</div>
<div id="piano-wrapper">
    <div class="piano">
        <div class="white-keys">
            <div class="keyboards" name="C1"></div>
            <div class="keyboards" name="D1"></div>
            <div class="keyboards" name="E1"></div>
            <div class="keyboards" name="F1"></div>
            <div class="keyboards" name="G1"></div>
            <div class="keyboards" name="A1"></div>
            <div class="keyboards" name="H1"></div>
            <div class="keyboards" name="C2"></div>
            <div class="keyboards" name="D2"></div>
            <div class="keyboards" name="E2"></div>
            <div class="keyboards" name="F2"></div>
            <div class="keyboards" name="G2"></div>
            <div class="keyboards" name="A2"></div>
            <div class="keyboards" name="H2"></div>
            <div class="keyboards" name="C3"></div>
        </div>
        <div class="black-keys">
            <div class="keyboards" name="Cis1"></div>
            <div class="keyboards" name="Es1"></div>
            <div class="keyboards key-space"></div>
            <div class="keyboards" name="Fis1"></div>
            <div class="keyboards" name="As1"></div>
            <div class="keyboards" name="B1"></div>
            <div class="keyboards key-space"></div>
            <div class="keyboards" name="Cis2"></div>
            <div class="keyboards" name="Es2"></div>
            <div class="keyboards key-space"></div>
            <div class="keyboards" name="Fis2"></div>
            <div class="keyboards" name="As2"></div>
            <div class="keyboards" name="B2"></div>
        </div>
    </div>
    <div class="piano">
        <div class="white-keys">
            <div class="keyboards" name="C3"></div>
            <div class="keyboards" name="D3"></div>
            <div class="keyboards" name="E3"></div>
            <div class="keyboards" name="F3"></div>
            <div class="keyboards" name="G3"></div>
            <div class="keyboards" name="A3"></div>
            <div class="keyboards" name="H3"></div>
            <div class="keyboards" name="C4"></div>
            <div class="keyboards" name="D4"></div>
            <div class="keyboards" name="E4"></div>
            <div class="keyboards" name="F4"></div>
            <div class="keyboards" name="G4"></div>
            <div class="keyboards" name="A4"></div>
            <div class="keyboards" name="H4"></div>
            <div class="keyboards" name="C5"></div>
        </div>
        <div class="black-keys">
            <div class="keyboards" name="Cis3"></div>
            <div class="keyboards" name="Es3"></div>
            <div class="keyboards key-space"></div>
            <div class="keyboards" name="Fis3"></div>
            <div class="keyboards" name="As3"></div>
            <div class="keyboards" name="B3"></div>
            <div class="keyboards key-space"></div>
            <div class="keyboards" name="Cis4"></div>
            <div class="keyboards" name="Es4"></div>
            <div class="keyboards key-space"></div>
            <div class="keyboards" name="Fis4"></div>
            <div class="keyboards" name="As4"></div>
            <div class="keyboards" name="B4"></div>
        </div>
    </div>
</div>

<div id="control-panel">
<div id="keyboard-size" class="block">
    <div class="th">キーボードサイズ</div>
    <div class="td">
        <input type="range" min="0" max="100" value="50" v-model="sizeValue" v-on:input="changeSize"/>
    </div><div class="td">
        {{ sizeValue }}
    </div>
</div>
<div id="sustain" class="block">
    <div class="th">持続</div>
    <div class="td">
        <label for="sustein">
            <input type="checkbox" id="sustein" name ="sustein"/>
            <span class="switch-label">持続する</span>
        </label>
    </div>
</div>
<div class="block">
    <div class="th">調</div>
    <div class="td">
        <span class="wrapSelect">
            <select id="scale">
                <option value="ave" selected="">平均律</option>
                <option value="C">C</option>
                <option value="Cis">C♯</option>
                <option value="D">D</option>
                <option value="Es">E♭</option>
                <option value="E">E</option>
                <option value="F">F</option>
                <option value="Fis">F♯</option>
                <option value="G">G</option>
                <option value="As">A♭</option>
                <option value="A">A</option>
                <option value="B">B♭</option>
                <option value="H">B</option>
            </select>
        </span>
        <label for="keyAuto">
            <input type="checkbox" id="keyAuto" name ="keyAuto"/>
            <span class="switch-label">自動</span>
        </label>
        <div>
            <label for="major">
                <input type="radio" name="key" id="major" value="major" checked="" />
                <span class="radio-label">長調</span>
            </label>
            <label for="minor">
                <input type="radio" name="key" id="minor" value="minor" />
                <span class="radio-label">短調</span>
            </label>
        </div>
    </div>
</div>
</div>
<div class="drawer" id="tone-color">
    <div class="block">
        <div class="th">音色</div>
        <div class="td">
            <div class="wrapSelect">
                <select id="toneColor">
                <option value="sine" selected="">正弦波</option>
                <option value="square">矩形波</option>
                <option value="sawtooth">鋸波</option>
                <option value="triangle">三角波</option>
                <!--option value="custom" disabled="">その他(未実装)</option-->
                </select>
            </div>
        </div>
    </div>
    <div id="attack" class="block">
        <div class="th">アタック</div>
        <div class="td">
            <input type="range" v-model="attackVal" v-on:input="changeValue" min="0" max="100" value="80"/>
        </div><div class="td">
            {{ attackVal }}
        </div>
    </div>
    <div id="release" class="block">
        <div class="th">リリース</div>
        <div class="td">
            <input type="range" v-model="releaseVal" v-on:input="changeValue" min="0" max="100" value="50"/>
        </div><div class="td">
            {{releaseVal}}
        </div>
    </div>
    <div class="block">
        <div class="th">音域</div>
        <div class="td">
            <div id="range-of-octave">
                <label for="low">
                    <input type="radio" name="range-of-octave" id="low" value="2" />
                    <span class="radio-label">低音</span>
                </label>
                <label for="midium">
                    <input type="radio" name="range-of-octave" id="midium" value="1" checked="" />
                    <span class="radio-label">中音</span>
                </label>
                <label for="high">
                    <input type="radio" name="range-of-octave" id="high" value="0" />
                    <span class="radio-label">高音</span>
                </label>
            </div>
        </div>
    </div>
    <div>&nbsp;
        <button class="close-window" onclick="showFromLeft('tone-color')">閉じる</button>
    </div>
</div>
<div class="drawer" id="metronome">
    <span id="metro-title">メトロノーム
            <div class="switch" style="display: inline-block">
                <label for="metro">
                    <input type="checkbox" id="metro" name="metro"/>
                    <span class="switch-label">再生する</span>
                </label>
            </div>
    </span>
    <div id="tempo" class="block">
        <div class="td">テンポ</div>
        <div class="td">
            <input type="range" v-model="tempoVal" min="40" max="300" value="100"/>
        </div><div class="td">
            {{ tempoVal }}
        </div>
    </div>
    <div id="stressVol" class="block">
        <div class="td">強拍</div>
        <div class="td">
            <input type="range" v-model="volume" min="0" max="100" value="100"/>
        </div><div class="td">
            {{ volume }}
        </div>
    </div>
    <div id="fourVol" class="block">
        <div class="td">4分音符</div>
        <div class="td">
            <input type="range" v-model="volume" min="0" max="100" value="80"/>
        </div><div class="td">
            {{ volume }}
        </div>
    </div>
    <div id="eightVol" class="block">
        <div class="td">8分音符</div>
        <div class="td">
            <input type="range" v-model="volume" min="0" max="100" value="20"/>
        </div><div class="td">
            {{ volume }}
        </div>
    </div>
    <div id="tripletVol" class="block">
        <div class="td">3連符</div>
        <div class="td">
            <input type="range" v-model="volume" min="0" max="100" value="0"/>
        </div><div class="td">
            {{ volume }}
        </div>
    </div>
    <div id="sixteenVol" class="block">
        <div class="td">16分音符</div>
        <div class="td">
            <input type="range" v-model="volume" min="0" max="100" value="0"/>
        </div><div class="td">
            {{ volume }}
        </div>
    </div>
    <div id="signature" class="block">
        <div class="td">拍子</div>
        <div class="td">
                <div class="signature" id="signature">
                    <div>
                        <label for="sign1">
                            <input type="radio" name="signature-numerator" id="sign1" value="1" />
                            <span class="radio-label">1</span>
                        </label>
                        <label for="sign2">
                            <input type="radio" name="signature-numerator" id="sign2" value="2" />
                            <span class="radio-label">2</span>
                        </label>
                        <label for="sign3">
                            <input type="radio" name="signature-numerator" id="sign3" value="3" />
                            <span class="radio-label">3</span>
                        </label>
                        <label for="sign4">
                            <input type="radio" name="signature-numerator" id="sign4" value="4" checked="" />
                            <span class="radio-label">4</span>
                        </label>
                    </div>
                    <label for="sign0">
                        <input type="radio" name="signature-numerator" id="sign0" value="other" />
                        <span class="radio-label">複合拍子</span>
                    </label>：
                    <input type="text" id="compound-signature" placeholder="2+3 etc...">
                </div>
            </div>
        </div>
        <div>
            <button class="close-window" onclick="showFromLeft('metronome')">閉じる</button>
        </div>
    </div> 
</div>
<div class="drawer" id="tuner">
    <div class="switch" style="display: inline-block">
        <label for="tuner-start">
            <input type="checkbox" id="tuner-start" name="tuner-start" />
            <span class="switch-label">開始する（PCのみ）</span>
        </label>
    </div>
    <div class="canvas-container">
        <canvas id="freq-spectrum"></canvas>
    </div>
    <div>
        <div>ピーク周波数<span id="peakFreq"></span> [Hz]</div>
        <div>ピーク音名<span id="peakTone"></span></div>
        <div>ズレ<span id="toneDiffrence"></span> [cent]</div>
        <div>&nbsp;
            <button class="close-window" onclick="showFromLeft('tuner')">閉じる</button>
        </div>
    </div>
</div>
<div class="drawer" id="settings">
    <h2>設定</h2>
    <div id="stdFreq" class="block">
        <div class="th">基準周波数</div>
        <div class="td">
            <input type="range" v-model="stdFreqVal" v-on:input="changeFreq" min="435" max="445" value="442"/>
        </div><div class="td">
            {{ stdFreqVal }}
        </div>
    </div>
    <div id="color-theme" class="block" v-on:change="changeColorTheme">
        <div class="th">色テーマ：</div>
        <div class="td">
            <label for="cute">
                <input type="radio" v-model="theme" id="cute" value="cute" />
                <span class="radio-label">Cute</span>
            </label>
            <label for="natural">
                <input type="radio" v-model="theme" id="natural" value="natural" />
                <span class="radio-label">Natural</span>
            </label>
            <label for="cool">
                <input type="radio" v-model="theme" id="cool" value="cool" />
                <span class="radio-label">Cool</span>
            </label>
        </div>
    </div>
</div>

</div>
<br />

<!--
<p>自動再生</p>
<label for="auto-player"><input type="checkbox" id="auto-player" /><span class="switch-label">再生／停止</span></label>
<textarea id="auto-play-text" placeholder="c,c,e,g|ceg|c"></textarea>
-->
<br />
<script>
window.AudioContext = window.AudioContext || window.webkitAudioContext;
const audioctx = new AudioContext();
const ana = audioctx.createAnalyser();
//const sizeElm = document.getElementById("size");
const pianoElm = document.getElementById("piano-wrapper");
const keyboards = document.getElementsByClassName("keyboards");
const controlElm = document.getElementById("control-panel");
const colorElm = document.getElementById("toneColor");
const scale = document.getElementById("scale");
const chordElm = document.getElementById("chordView");
const attackElm = document.getElementById("attack");
const releaseElm = document.getElementById("release");
const keyElm = document.querySelectorAll("input[name='key']");
const rangeElm = document.getElementById("range-of-octave").querySelectorAll("input");
const autoElm = document.getElementById("keyAuto");
let majorOrMinor;
let currentOctave;
const freqRatio = {};
freqRatio.major = [1, 25/24, 9/8, 6/5, 5/4, 4/3, 25/18, 3/2, 25/16, 5/3, 9/5, 15/8, 2];
freqRatio.minor = [1, 27/25, 9/8, 6/5, 5/4, 4/3, 36/25, 3/2, 8/5, 5/3, 9/5, 15/8, 2];
const toneNames = [
    "A0", "B0", "H0",
    "C1","Cis1", "D1", "Es1", "E1", "F1", "Fis1", "G1", "As1", "A1", "B1", "H1",
    "C2","Cis2", "D2", "Es2", "E2", "F2", "Fis2", "G2", "As2", "A2", "B2", "H2",
    "C3","Cis3", "D3", "Es3", "E3", "F3", "Fis3", "G3", "As3", "A3", "B3", "H3",
    "C4","Cis4", "D4", "Es4", "E4", "F4", "Fis4", "G4", "As4", "A4", "B4", "H4",
    "C5"
];
const scales = ["A", "B", "H", "C","Cis", "D", "Es", "E", "F", "Fis", "G", "As"];
const tone = {};
const playing = {};
let isLongtone = false;

const keyboardSize = new Vue({
    el: "#keyboard-size",
    data: {
        sizeValue: window.localStorage.getItem("size") || 50
    },
    created: function() {
        this.changeSize()
    },
    methods: {
        changeSize: function() {
            window.localStorage.setItem("size", this.sizeValue);
            const size = 1 + this.sizeValue / 100;
            for (const e of pianoElm.querySelectorAll(".white-keys .keyboards")){
                e.style.width = 44 * size + "px";
            }
            for (const e of pianoElm.querySelectorAll(".black-keys .keyboards")){
                e.style.width = 30 * size + "px";
                e.style.marginRight = 14 * size + "px";
            }
            for (const e of pianoElm.querySelectorAll(".black-keys")){
                e.style.left = 29 * size + "px";
            }
        }
    }
});

new Vue({
    el: "#color-theme",
    data: {
        theme: window.localStorage.getItem("colorTheme") || "natural"
    },
    created: function() {
        this.changeColorTheme();
    },
    methods: {
        changeColorTheme: function() {
            window.localStorage.setItem("colorTheme", this.theme);
            const colorProp = ["--active", "--active-grad", "--background", "--border", "--shadow"];
            for (const prop of colorProp) {
                const style = getComputedStyle(document.documentElement);
                const property = style.getPropertyValue(prop + "-" + this.theme);
                document.documentElement.style.setProperty(prop, property);
            }
        }
    }
})

setMajorOrMinor();
setRangeOctave();
pianoElm.addEventListener("touchstart", (e) => {
    const toneName = e.target.getAttribute("name");
    if (toneNames.includes(toneName)) {
        e.preventDefault();
        playTone(toneName, e.target);
        e.target.classList.add("keyboard-press");
    }
});
function showFromLeft(id) {
    with (document.getElementById(id)) {
        style.transition = "";
        classList.toggle("show");
    }
}
let attackTimeConst = 20 * 1e-3;
const attack = new Vue({
    el: "#attack",
    data: {
        attackVal: window.localStorage.getItem("attack") || 80
    },
    methods: {
        changeValue: () => {
            attackTimeConst = (100 - attack.attackVal) * 1e-3;
            window.localStorage.setItem("attack", attack.attackVal);
        }
    }
});
let releaseTimeConst = 50 * 1e-3;
const release = new Vue({
    el: "#release",
    data: {
        releaseVal: window.localStorage.getItem("release") || 50
    },
    methods: {
        changeValue: () => {
            releaseTimeConst = (100 - release.releaseVal) * 1e-3;
            window.localStorage.setItem("release", release.releaseVal);
        }
    }
});
function playTone(toneName, e) {
    if (isLongtone) {
        stopPlay();
    }
    if (!playing[toneName]) {
        const osc = audioctx.createOscillator();
        const gain = audioctx.createGain();
        const ana = audioctx.createAnalyser();
        const i = toneNames.indexOf(toneName);
        playing[toneName] = {osc, gain, ana, elm: e, i};
        let keyScale = scale.value;
        if (autoElm.checked) {
            let playingTones = Object.keys(playing).filter(key => playing[key]);
            playingTones = playingTones.map(str => str.slice(0, -1));
            playingTones = [...new Set(playingTones)];
            if (playingTones.length >= 3) {
                let lowest = 88;
                for (let j = 0; j < Object.keys(playing).length; j++) {
                    if (playing[Object.keys(playing)[j]].i < lowest) {
                        lowest = playing[Object.keys(playing)[j]].i;
                    }
                }
                const chord = chordCheck(playingTones, toneNames[lowest].slice(0, -1));
                if (chord[0]) {
                    keyScale = chord[0].key;
                    let chordListStr = "";
                    for (const obj of chord) {
                        chordListStr = obj.key + " " +obj.chordStr;
                    }
                    chordElm.textContent = chordListStr;
                    changeToneFreq(keyScale);
                    scale.value = keyScale;
                    if (chord[0].secondTone == 3) {
                        keyElm[1].checked = true;
                    } else {
                        keyElm[0].checked = true;
                    }
                }
            }
        }

        const freq = getFreqByScaleInterval(keyScale, i);
        osc.frequency.value = freq;
        osc.type = colorElm.value;
        gain.gain.value = 0;
        osc.connect(gain);
        gain.connect(ana);
        ana.connect(audioctx.destination);
        osc.start();
        gain.gain.setTargetAtTime(1, audioctx.currentTime, attackTimeConst);
    }
}
colorElm.onchange = () => {
    changeToneType(colorElm.value);
}
scale.onchange = () => changeToneFreq();

function changeToneType(type) {
    for (let osc of Object.keys(playing)) {
        playing[osc].osc.type = type;
    }
}
function changeToneFreq(key = scale.value) {
    for (let osc of Object.keys(playing)) {
        const freq = getFreqByScaleInterval(key, toneNames.indexOf(osc));
        playing[osc].osc.frequency.value = freq;
    }
}
function chordCheck(tones, lowest) {
    if (tones.length > 4) {
        return false;
    }
    let notes = [];
    const n = tones.length;
    tones.forEach(note => {
        notes.push(scales.indexOf(note));
    });
    notes.sort((a, b) => {
        return (a > b) ? 1 : -1;
    });

    const lowestNum = scales.indexOf(lowest);
    let splitIndex = 0;
    while (notes[splitIndex++] < lowestNum) continue;
    splitIndex--;
    notes = [...notes.slice(splitIndex, n), ...notes.slice(0, splitIndex)];
    const toneDistance = (base, higher) => {
        return (higher > base) ? higher - base : (12 + higher - base) % 12;
    }
    const result = [];
    for (let i = 0; i < n; i++) {
        const distances = [];
        for (let j = 0; j < n; j++) {
            distances.push(toneDistance(notes[0], notes[j]));
        }
        const baseToneName = scales[notes[0]];
        const chordList = {
            "0,4,7": "major",
            "0,3,7": "minor",
            "0,5,7": "sus4",
            "0,2,7": "sus2",
            "0,4,7,10": "7",
            "0,3,7,10": "m7",
            "0,4,7,11": "M7",
            "0,3,6,10": "m7♭5",
            "0,5,7,10": "7sus4",
            "0,4,8": "aug",
            "0,3,6": "diminish",
            "0,3,7,11": "mM7",
            "0,4,7,9": "6",
            "0,3,7,9": "m6",
            "0,4,6,10": "7♭5",

            // "0,2,4,7": "I on II"
        }
        const prop = distances.join();
        if (prop in chordList) {
            result.push({
                key: baseToneName,
                chordStr: chordList[prop],
                secondTone: distances[1]
            });
        } else {
            notes.push(notes[0]);
            notes.shift();
        }
    }
    return result;
}

const stdFreqElm = new Vue({
    el: "#stdFreq",
    data: {
        stdFreqVal: 442
    },
    methods: {
        changeFreq: () => {
            if (Object.keys(playing).length) {
                changeToneFreq();
            }
        }
    }
});

function getFreqByScaleInterval(scale, interval) {
    let stdInterval = scales.indexOf(scale);
    const stdFreq = stdFreqElm.stdFreqVal / (2 ** currentOctave);
    const currentFreq = freqRatio[majorOrMinor];
    if (~stdInterval) {
        const referFreq = stdFreq / 2 * 2 ** (stdInterval / 12);
        const degree = (12 + interval - stdInterval) % 12;
        const octave = ~~((12 + interval - stdInterval) / 12);
        return (referFreq * currentFreq[degree]) * 2 ** octave;
    } else {
        return stdFreq * (2 ** (interval / 12));
    }
}

function setMajorOrMinor() {
    for (let elm of keyElm) {
        if (elm.checked) {
            majorOrMinor = elm.value;
        }
    }
}
function setRangeOctave() {
    for (let elm of rangeElm) {
        if (elm.checked) {
            currentOctave = elm.value - 0;
        }
    }
}
for (let elm of keyElm) {
    elm.onchange = () => {
        setMajorOrMinor();
        changeToneFreq();
    }
}
for (let elm of rangeElm) {
    elm.onchange = () => {
        setRangeOctave();
        changeToneFreq();
    }
}
pianoElm.addEventListener("touchend", (e) => {
    const toneName = e.target.getAttribute("name");
    if (toneName) {
        e.preventDefault();
        stopPlay(toneName, e);
    }   
});
const susteinElm = document.getElementById("sustein");
susteinElm.onchange = () => {
    if (!susteinElm.checked) {
        stopPlay();
    }
}
function stopPlay(toneName, event){
    if(!toneName) {
        for (let osc of Object.keys(playing)) {
            playing[osc].gain.gain.setTargetAtTime(0, audioctx.currentTime, releaseTimeConst);
            playing[osc].osc.stop(audioctx.currentTime + 0.05);
            playing[osc].elm.classList.remove("keyboard-press");
            delete playing[osc];
        }
        isLongtone = false;
    }
    if (susteinElm.checked) {
        if(event) {
            isLongtone = !event.touches[0];
        }
    } else if(playing[toneName]) {
        playing[toneName].gain.gain.setTargetAtTime(0, audioctx.currentTime, releaseTimeConst);
        playing[toneName].osc.stop(audioctx.currentTime + 5);
        playing[toneName].elm. classList.remove("keyboard-press");
        delete playing[toneName];
    }
}
class MetronomeNote {
    constructor(beatInt, name, elmId, initVol, freq) {
        this.beatInterval = beatInt;
        this.noteName = name;
        this.element = new Vue({
            el: "#" + elmId,
            data: {
                volume: initVol
            },
            methods: {
                changeLevel() {
                    this.level = this.element.volume;
                }
            }
        });
        //this.paramElement = document.getElementById(pElmId);
        this.frequency = freq;
        this.level = this.element.volume;

        this.element.oninput = this.showParam.bind(this);
    }
    init() {
        this.osc = this.ctx.createOscillator();
        this.gain = this.ctx.createGain();

        this.osc.frequency.value = this.frequency;
        this.gain.gain.value = 0;
        this.osc.connect(this.gain);
        this.gain.connect(this.ctx.destination);
        /*
            if (this.buffer) {
                this.source = this.ctx.createBufferSource();
                this.source.buffer = AudioBuffer;
                this.source.connect(this.gain);  
                this.gain.connect(this.ctx.destination);  
                this.source.start();
                console.log(this.source)
            }
            */
        this.osc.start();
    }
    showParam() {
        //this.paramElement.textContent = this.element.value;
        this.level = this.element.volume;
    }
    reserveBeat(current48Beat, nextBeatTime, currentTimeSignature) {
        if (this.beatInterval) {
            if (current48Beat % this.beatInterval === 0) {
                this.gain.gain.setValueAtTime(this.element.volume / 50, nextBeatTime);
                this.gain.gain.linearRampToValueAtTime(0, nextBeatTime + 0.05);
            }
        } else if (!currentTimeSignature && !current48Beat) {
            this.gain.gain.setValueAtTime(this.element.volume / 50, nextBeatTime);
            this.gain.gain.linearRampToValueAtTime(0, nextBeatTime + 0.05);   
        }
    }
    set audioContext(ctx) {
        this.ctx = ctx;
        this.init();
    }
    set arrayBuffer(buffer) {
        this.buffer = buffer;
        this.init();
    }
}
/*
const stressBase64Data = "data:audio/wav;base64,UklGRuAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YbwAAAAnAEn8rfeB8tTs1ObX4Ejb6tWw0IfLQMaZwGq68rMWrd2laJ6Al/GR640EjpiTIJzep8q2aceN2ADpaPjHAloGYAcQBhkDRgDj/sX/MgKRCJUT/SAfMPk/s05tWLhbD1zMVrVKgzphJVgN8veC7uTy+/rxAOsBIwA0/ab6AvnU93r2xPTy8mjxKPB671vve+8a8Crxd/Le82n14fYg+Av53vly+uL6N/t++7D75/s8/Lr8U/0m/jX/bwD3AQ==";
let AudioBuffer;
function base64dataToArrayBuffer(data) {  
    /*
  var byteString = atob(data.split(',')[1])
  var len = byteString.length;
  var buffer = new Uint8Array(len);
  for (var i=0; i<len; ++i) {
    buffer[i] = byteString.charCodeAt(i);
  }
  return Uint8Array.from(atob(data.split(",")[1]), data => data.charCodeAt(0)).buffer
  //return buffer.buffer;
};
*/
const stress = new MetronomeNote(0, "stress", "stressVol", 100, 2400);
const four = new MetronomeNote(12, "four", "fourVol", 80, 1200);
const eight = new MetronomeNote(6, "eight", "eightVol", 20, 1200);
const triplet = new MetronomeNote(4, "triplet", "tripletVol", 0, 1200);
const sixteen = new MetronomeNote(3, "sixteen", "sixteenVol", 0, 1200);

const metronomeNotes = {
    stress, four, eight, triplet, sixteen
};
for (let note of Object.values(metronomeNotes)) {
    note.showParam();
}
function showParam(elm, name) {
    document.getElementById(name).textContent = elm.value;
}
const tempo = new Vue({
    el: "#tempo",
    data: {
        tempoVal: 100
    },
    methods: {
        changeTempo: () => {

        }
    }
})
const timeSignatureElm = document.getElementById("signature");
class MetronomeBeater {
    constructor() {   
    }
    start () {
        this.ctx = new AudioContext();
        this.currentTimeSignature = 0;
        this.current48Beat = 0;
        this.currentSignatureIndex = 0;
        this.isChangedSignature = false;
        const nowTimeStamp = performance.now();
        this.lastBeatTimeStamp = nowTimeStamp;
        this.nextBeatTimeStamp = nowTimeStamp;
        this.nextTimeSignature = this.nextNote.bind(this);
        this.baseTimeStamp = nowTimeStamp - this.ctx.currentTime * 1000;
        for (let note of Object.values(metronomeNotes)) {
            note.audioContext = this.ctx;
        }
        this.setTimeSignatureNumerator();
        (this.scheduler.bind(this))();
        this.intervalId = setInterval(this.scheduler.bind(this), 500);
        return {
            ctx: this.ctx,
            id: this.intervalId
        };
    }
    currentTimeStamp() {
        return this.baseTimeStamp + this.ctx.currentTime * 1000;
    }
    timeStampToAudioContextTime(timeStamp) {
        return (timeStamp - this.baseTimeStamp) / 1000;
    }
    nextNote() {
        const beatTick = 60 * 1000 / tempo.tempoVal;
        if (this.isChangedSignature) {
            this.currentSignatureIndex = 0;
            this.isChangedSignature = false;
        }
        this.nextBeatTimeStamp += beatTick / 12;
        this.current48Beat++;
        this.current48Beat %= 12;
        if (!this.current48Beat) {
            this.currentTimeSignature++;
            this.currentSignatureIndex %= this.signature.length;
            if (this.currentTimeSignature >= this.signature[this.currentSignatureIndex]) {
                this.currentTimeSignature = 0;
                this.currentSignatureIndex++;
                this.currentSignatureIndex %= this.signature.length;
            }
        }
        return this;
    }
    setTimeSignatureNumerator() {
        let selectedSignatureElm;
        for (let elm of timeSignatureElm.querySelectorAll("input")) {
            if (elm.checked) {
                selectedSignatureElm = elm;
            }
        }
        if (!(selectedSignatureElm.value - 0)) {
            const compoundElm = document.getElementById("compound-signature");
            this.signature = compoundElm.value.split(/\+|,| /);
            if (!this.signature.length) {
                this.signature = 1;
            }
        } else {
            this.signature = [selectedSignatureElm.value - 0];   
        }
    }
    scheduler() {
        const now = this.currentTimeStamp();
        while (this.nextBeatTimeStamp < now + 700) {
            let next48BeatTime = this.timeStampToAudioContextTime(this.nextBeatTimeStamp);
            for (let note of Object.values(metronomeNotes)) {
                note.reserveBeat(this.current48Beat, next48BeatTime, this.currentTimeSignature);
            }
            this.nextNote();
        }
    }
}

const beat = new MetronomeBeater();
const metroElm = document.getElementById("metro");
const tempoElm = document.getElementById("tempo");
let metroIntervalId, metroctx;
metroElm.onchange = metroHandler;
metroElm.checked = false;
function metroHandler() {
    if (metroElm.checked) {
        const obj = {id: metroIntervalId, ctx: metroctx} = beat.start();
    } else if (metroctx) {
        metroctx.close();
        clearInterval(metroIntervalId);
        metroIntervalId = null;
    }
}

for (let elm of timeSignatureElm.querySelectorAll("input")) {
    elm.onchange = () => {
        beat.setTimeSignatureNumerator();
        beat.isChangedSignature = true;
    }
}

/**
* range関連
*/
for (let elm of document.querySelectorAll("input[type='range']")) {
    const beforeElm = document.createElement("input");
     with (beforeElm) {
        type = "button";
        classList.add("minus-button");
        value = "ー";
        onclick = prevent;
        addEventListener("touchstart", handler);
    }
    const afterElm = document.createElement("input");
    afterElm.type = "button";
    afterElm.classList.add("plus-button");
    afterElm.value = "＋";
    afterElm.onclick = prevent;
    afterElm.addEventListener("touchstart", handler);

    elm.insertAdjacentElement("beforebegin", beforeElm);
    elm.insertAdjacentElement("afterend", afterElm);

    controlElm.style.display = "none";
    controlElm.style.display = "";    

    function handler(e) {
        let elm;
        switch (e.target.value) {
            case "＋":
                elm = e.target.previousElementSibling;
                elm.value++;
                break;
            case "ー":
                elm = e.target.nextElementSibling;
                elm.value--;
                break;
        }
        elm.dispatchEvent(new Event("input"));
    }
    function prevent(e){
        e.preventDefault();
    }
}

/* 自動再生関連
const tonesArr = ["A", "B", "H", "C","Cis", "D", "Es", "E", "F", "Fis", "G", "As"];
const stdPitch = 442;
const tempo = 60;

const controler = document.getElementById("auto-player");
const textareaElm = document.getElementById("auto-play-text");
textareaElm.textContent = "c|cg|ceg,"
let obj;
let playDataByBar, playDataByNote, playDataByTone;
controler.onchange = () => {
    if (controler.checked) {
        // a|a,b,c|abc -> ["a","a,b,c","abc"]
        playDataByBar = textareaElm.textContent.split("|");
        // ->[["a"], ["a", "b", "c"], ["abc"]]
        playDataByNote = playDataByBar.map(notes => notes.split(","));
        // ->[[[a]], [[a],[b],[c]], [[a,b,c]]]
        playDataByTone = playDataByNote.map(note => note.map(tones => tones.split("")));

        obj = startAutoPlay();
    } else {
        obj.ctx.close();
        clearInterval(obj.id);
    }
}

function startAutoPlay() { 
    const ctx = new AudioContext(); 
    const baseTimeStamp = performance.now() - ctx.currentTime * 1000; 
    let currentBar = 0; 
    let currentIndex = 0; 
 
    const nowTime = performance.now(); 
    let lastNoteTimeStamp = nowTime; 
    let nextNoteTimeStamp = lastNoteTimeStamp;
    let nextNoteTime = timeStampToAudioContextTime(nextNoteTimeStamp);

 
    function scheduler() { 
        const now = currentTimeStamp(); 
        while (nextNoteTimeStamp < now + 800) { 
            for (let tone of playDataByTone) { 
                nextNoteTime = reserveNote(nextNoteTime); 
            } 
        } 
    } 
    scheduler(); 
    const intervalId = setInterval(scheduler, 500); 
    return { 
        ctx, 
        id: intervalId 
    };

    function reserveNote(nextNoteTime) {
        const tonesReserve = playDataByTone[currentBar][currentIndex]
        nextNote();
        const nextnextNoteTime = timeStampToAudioContextTime(nextNoteTimeStamp);
        for (const tone of tonesReserve) {
            const freq = stdPitch * (2 ** (tonesArr.indexOf(tone.toUpperCase()) / 12)); 
            const osc = ctx.createOscillator();
            const gain = ctx.createGain(); 
            osc.frequency.value = freq;
            gain.gain.value = 0;
            gain.gain.setValueAtTime(1, nextNoteTime);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(nextnextNoteTime);
        
        return nextnextNoteTime;
    } 
    function nextNote() { 
        const beatTick = 60 * 1000 / tempo;
        const notesInBar = playDataByNote[currentBar].length; 
        nextNoteTimeStamp += beatTick / notesInBar; 
        currentIndex++; 
        if (currentIndex === notesInBar) { 
            currentIndex = 0; 
            currentBar++;
            if(currentBar === playDataByBar.length) {
                currentBar = 0;
            }
        } 
    } 
    function currentTimeStamp() { 
        return baseTimeStamp + ctx.currentTime * 1000; 
    } 
    function timeStampToAudioContextTime(timeStamp) { 
        return (timeStamp - baseTimeStamp) / 1000; 
    } 
}
*/

/* チューナー作る */
const startTuning = document.getElementById("tuner-start");
startTuning.checked = false;
const spectrumCanvas = document.getElementById("freq-spectrum");
const canvasCtx = spectrumCanvas.getContext("2d");
const pixelRatio = window.devicePixelRatio || 1;
let mediaStream;
let canvasWidth = spectrumCanvas.parentNode.clientWidth;
let canvasHeight = spectrumCanvas.parentNode.clientHeight;
resizeCanvas();
window.onresize = resizeCanvas;
function resizeCanvas() {
    spectrumCanvas.style.width = null;
    spectrumCanvas.style.height = null;
    spectrumCanvas.parentNode.style.width = null;
    canvasWidth = spectrumCanvas.parentNode.clientWidth;
    canvasHeight = spectrumCanvas.parentNode.clientHeight;
    spectrumCanvas.width = canvasWidth * pixelRatio;
    spectrumCanvas.height = canvasHeight * pixelRatio;
    canvasCtx.scale(pixelRatio, pixelRatio);
    spectrumCanvas.style.width = canvasWidth + "px";
    spectrumCanvas.style.height = canvasHeight + "px";
}

document.getElementById("tuner-start").onchange = () => {
    canvasCtx.fillStyle = 'rgba(0, 0, 0, 1)';
    canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);
    if (!startTuning.checked && mediaStream) {
        mediaStream.getAudioTracks().forEach((track) => {
            track.stop();
        })
    } else {
        navigator.mediaDevices.getUserMedia({audio: true, video: false}).then((stream) => {
            mediaStream = stream;
            const tunerCtx = new AudioContext();
            // tunerCtx.sampleRate = 2 ** 14;
            const ana = tunerCtx.createAnalyser();
            const lowFilter = tunerCtx.createBiquadFilter();
            const highFilter = tunerCtx.createBiquadFilter();
            const source = tunerCtx.createMediaStreamSource(stream);
            const processor = tunerCtx.createScriptProcessor(4096, 1, 1);
            ana.fftSize = 2 ** 15;
            ana.minDecibels = -60;
            const bufferLength = ana.frequencyBinCount;
            let dataArray = new Uint8Array(bufferLength);

            ana.smoothingTimeConstant = 0.5;
            lowFilter.type = "lowpass";
            lowFilter.frequency = 1000;
            //highFilter.type = "highpass";
            //highFilter.frequency = 100;
            highFilter.gain.value = 10;
            source.connect(lowFilter);
            lowFilter.connect(ana);
            //highFilter.connect(ana);
            ana.connect(processor);
            // processor.connect(tunerCtx.destination);

            const barWidth = canvasWidth / bufferLength;
            processor.onaudioprocess = e => {
                ana.getByteFrequencyData(dataArray);
                canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                canvasCtx.beginPath();

                let peakFreqIndex = 0;
                for (var i = 0, len = dataArray.length / 8; i < len; i++) {
                    var x = (i / len) * canvasWidth;
                    var y = (1 - (dataArray[i] / 255)) * canvasHeight;
                    if (i === 0) {
                        canvasCtx.moveTo(x, y);
                    } else {
                        canvasCtx.lineTo(x, y);
                    }
                    var f = Math.floor(i * tunerCtx.sampleRate / ana.fftSize);

                    if ((f % 500) === 0) {
                        var text = (f / 1000) + 'kHz';
                        canvasCtx.moveTo(x, canvasHeight);
                        canvasCtx.lineTo(x, 0);
                        canvasCtx.fillText(text, x, canvasHeight);
                    }
                    if (dataArray[peakFreqIndex] < dataArray[i]) {
                        peakFreqIndex = i;
                    }
                    const peakFreq = peakFreqIndex * tunerCtx.sampleRate / ana.fftSize;
                    document.getElementById("peakFreq").textContent = peakFreq;
                    if (peakFreq) {
                        let logFreq = (12 * Math.log2(peakFreq / stdFreqElm.stdFreqVal)) % 12;
                        let toneIndex = 12 + Math.round(logFreq) % 12;
                        document.getElementById("peakTone").textContent = scales[toneIndex];
                        document.getElementById("toneDiffrence").textContent = (toneIndex - logFreq);
                    }
                }

                canvasCtx.moveTo(canvasWidth, canvasHeight);
                canvasCtx.lineTo(canvasWidth, 0);

                var textYs = ['1.00', '0.50', ''];
                canvasCtx.font = "0.95em serif";
                for (var i = 0, len = textYs.length; i < len; i++) {
                    var text = textYs[i];
                    var gy   = (1 - parseFloat(text)) * canvasHeight;
                    canvasCtx.moveTo(0, gy);
                    canvasCtx.lineTo(canvasWidth, gy);
                    canvasCtx.fillText(text, 0, gy);
                }

                canvasCtx.stroke();
            }
        });
    }
}

for (const drawerElm of document.querySelectorAll(".drawer")) {
    let startX, startY;

    drawerElm.addEventListener("touchstart", (e) => {
        startX = e.changedTouches[0].pageX - drawerElm.offsetLeft;
        startY = e.changedTouches[0].pageY - drawerElm.offsetTop;
        drawerElm.classList.add("dragging");
    })
    drawerElm.addEventListener("touchmove", (e) => {
        if (e.target.tagName == "DIV") {
            e.preventDefault();
            drawerElm.style.left = e.changedTouches[0].pageX - startX + "px";
            drawerElm.style.top = e.changedTouches[0].pageY - startY + "px";   
        }
    });
    drawerElm.addEventListener("touchend", (e) => {
        drawerElm.classList.remove("dragging");     
    })
}
</script>
</body>
</html>
